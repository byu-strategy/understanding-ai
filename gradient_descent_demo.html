<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Visualization</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        .control-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-item label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }
        .control-item input {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            width: 120px;
            transition: border-color 0.3s;
        }
        .control-item input:focus {
            outline: none;
            border-color: #667eea;
        }
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        .plots-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        .plot-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .plot-title {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            font-weight: 600;
            color: #495057;
        }
        .plot-content {
            height: 400px;
        }
        .info-panel {
            padding: 20px;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            margin: 20px;
            border-radius: 6px;
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        .info-panel p {
            margin: 5px 0;
            color: #424242;
        }
        .step-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .step-item {
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .step-item strong {
            color: #667eea;
        }
        @media (max-width: 768px) {
            .plots-container {
                grid-template-columns: 1fr;
            }
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .control-item input {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Gradient Descent Visualization</h1>
            <p>Interactive demonstration of gradient descent optimization for linear regression</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <div class="control-item">
                    <label for="w1-start">Starting Weight 1 (w₁):</label>
                    <input type="number" id="w1-start" value="2.0" step="0.1">
                </div>
                <div class="control-item">
                    <label for="w2-start">Starting Weight 2 (w₂):</label>
                    <input type="number" id="w2-start" value="1.5" step="0.1">
                </div>
                <div class="control-item">
                    <label for="learning-rate">Learning Rate (α):</label>
                    <input type="number" id="learning-rate" value="0.1" step="0.01" min="0.001" max="1">
                </div>
                <div class="control-item">
                    <label for="max-steps">Max Steps:</label>
                    <input type="number" id="max-steps" value="50" min="1" max="200">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="startGradientDescent()">Start Gradient Descent</button>
                <button class="btn-secondary" onclick="resetPlots()">Reset</button>
                <button class="btn-success" onclick="stepByStep()">Step by Step</button>
            </div>
        </div>

        <div class="info-panel">
            <h3>Current Status</h3>
            <div class="step-info">
                <div class="step-item">
                    <strong>Step:</strong> <span id="current-step">0</span>
                </div>
                <div class="step-item">
                    <strong>w₁:</strong> <span id="current-w1">2.000</span>
                </div>
                <div class="step-item">
                    <strong>w₂:</strong> <span id="current-w2">1.500</span>
                </div>
                <div class="step-item">
                    <strong>MSE:</strong> <span id="current-mse">0.000</span>
                </div>
                <div class="step-item">
                    <strong>Gradient:</strong> <span id="current-gradient">[0.000, 0.000]</span>
                </div>
            </div>
        </div>

        <div class="plots-container">
            <div class="plot-wrapper">
                <div class="plot-title">3D Surface Plot - Mean Squared Error</div>
                <div class="plot-content" id="surface-plot"></div>
            </div>
            <div class="plot-wrapper">
                <div class="plot-title">Contour Plot - Gradient Descent Path</div>
                <div class="plot-content" id="contour-plot"></div>
            </div>
        </div>
    </div>

    <script>
        // Generate synthetic data for linear regression
        function generateData() {
            const n = 100;
            const x1 = Array.from({length: n}, () => Math.random() * 4 - 2);
            const x2 = Array.from({length: n}, () => Math.random() * 4 - 2);
            const noise = Array.from({length: n}, () => (Math.random() - 0.5) * 0.5);
            
            // True weights: w1 = 1.5, w2 = 0.8
            const trueW1 = 1.5;
            const trueW2 = 0.8;
            const y = x1.map((val, i) => trueW1 * val + trueW2 * x2[i] + noise[i]);
            
            return { x1, x2, y, trueW1, trueW2 };
        }

        const data = generateData();
        let currentStep = 0;
        let gradientPath = [];
        let isRunning = false;
        let stepInterval = null;

        // Calculate MSE for given weights
        function calculateMSE(w1, w2) {
            let mse = 0;
            for (let i = 0; i < data.x1.length; i++) {
                const predicted = w1 * data.x1[i] + w2 * data.x2[i];
                const error = predicted - data.y[i];
                mse += error * error;
            }
            return mse / data.x1.length;
        }

        // Calculate gradient
        function calculateGradient(w1, w2) {
            let gradW1 = 0;
            let gradW2 = 0;
            
            for (let i = 0; i < data.x1.length; i++) {
                const predicted = w1 * data.x1[i] + w2 * data.x2[i];
                const error = predicted - data.y[i];
                gradW1 += 2 * error * data.x1[i];
                gradW2 += 2 * error * data.x2[i];
            }
            
            return [gradW1 / data.x1.length, gradW2 / data.x1.length];
        }

        // Create 3D surface plot
        function createSurfacePlot() {
            const w1Range = Array.from({length: 50}, (_, i) => -3 + i * 0.12);
            const w2Range = Array.from({length: 50}, (_, i) => -3 + i * 0.12);
            
            const z = [];
            for (let i = 0; i < w1Range.length; i++) {
                z[i] = [];
                for (let j = 0; j < w2Range.length; j++) {
                    z[i][j] = calculateMSE(w1Range[i], w2Range[j]);
                }
            }

            const surfaceData = [{
                type: 'surface',
                x: w1Range,
                y: w2Range,
                z: z,
                colorscale: 'Viridis',
                opacity: 0.8,
                showscale: true,
                colorbar: {title: 'MSE'}
            }];

            const layout = {
                title: 'Mean Squared Error Surface',
                scene: {
                    xaxis: {title: 'Weight 1 (w₁)'},
                    yaxis: {title: 'Weight 2 (w₂)'},
                    zaxis: {title: 'MSE'},
                    camera: {
                        eye: {x: 1.5, y: 1.5, z: 1.5}
                    }
                },
                margin: {l: 0, r: 0, t: 50, b: 0},
                height: 400
            };

            Plotly.newPlot('surface-plot', surfaceData, layout);
        }

        // Create contour plot
        function createContourPlot() {
            const w1Range = Array.from({length: 50}, (_, i) => -3 + i * 0.12);
            const w2Range = Array.from({length: 50}, (_, i) => -3 + i * 0.12);
            
            const z = [];
            for (let i = 0; i < w1Range.length; i++) {
                z[i] = [];
                for (let j = 0; j < w2Range.length; j++) {
                    z[i][j] = calculateMSE(w1Range[i], w2Range[j]);
                }
            }

            const contourData = [{
                type: 'contour',
                x: w1Range,
                y: w2Range,
                z: z,
                colorscale: 'Viridis',
                showscale: true,
                colorbar: {title: 'MSE'},
                contours: {
                    coloring: 'heatmap',
                    showlabels: true
                }
            }];

            const layout = {
                title: 'Contour Plot with Gradient Descent Path',
                xaxis: {title: 'Weight 1 (w₁)'},
                yaxis: {title: 'Weight 2 (w₂)'},
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 400
            };

            Plotly.newPlot('contour-plot', contourData, layout);
        }

        // Update plots with current path
        function updatePlots(w1, w2) {
            // Update surface plot with current point
            const surfacePoint = [{
                type: 'scatter3d',
                x: [w1],
                y: [w2],
                z: [calculateMSE(w1, w2)],
                mode: 'markers',
                marker: {
                    size: 8,
                    color: 'red',
                    symbol: 'diamond'
                },
                name: 'Current Point'
            }];

            Plotly.addTraces('surface-plot', surfacePoint);

            // Update contour plot with path
            if (gradientPath.length > 0) {
                const pathData = [{
                    type: 'scatter',
                    x: gradientPath.map(p => p.w1),
                    y: gradientPath.map(p => p.w2),
                    mode: 'lines+markers',
                    line: {color: 'red', width: 3},
                    marker: {size: 6, color: 'red'},
                    name: 'Gradient Descent Path'
                }];

                Plotly.addTraces('contour-plot', pathData);
            }
        }

        // Update info panel
        function updateInfo(w1, w2, step) {
            const mse = calculateMSE(w1, w2);
            const gradient = calculateGradient(w1, w2);
            
            document.getElementById('current-step').textContent = step;
            document.getElementById('current-w1').textContent = w1.toFixed(3);
            document.getElementById('current-w2').textContent = w2.toFixed(3);
            document.getElementById('current-mse').textContent = mse.toFixed(3);
            document.getElementById('current-gradient').textContent = `[${gradient[0].toFixed(3)}, ${gradient[1].toFixed(3)}]`;
        }

        // Perform one gradient descent step
        function gradientDescentStep(w1, w2, learningRate) {
            const gradient = calculateGradient(w1, w2);
            const newW1 = w1 - learningRate * gradient[0];
            const newW2 = w2 - learningRate * gradient[1];
            return { w1: newW1, w2: newW2, gradient };
        }

        // Start gradient descent
        function startGradientDescent() {
            if (isRunning) return;
            
            isRunning = true;
            currentStep = 0;
            gradientPath = [];
            
            let w1 = parseFloat(document.getElementById('w1-start').value);
            let w2 = parseFloat(document.getElementById('w2-start').value);
            const learningRate = parseFloat(document.getElementById('learning-rate').value);
            const maxSteps = parseInt(document.getElementById('max-steps').value);
            
            gradientPath.push({ w1, w2 });
            
            // Clear previous plots
            Plotly.purge('surface-plot');
            Plotly.purge('contour-plot');
            createSurfacePlot();
            createContourPlot();
            
            function runStep() {
                if (currentStep >= maxSteps || !isRunning) {
                    isRunning = false;
                    return;
                }
                
                const result = gradientDescentStep(w1, w2, learningRate);
                w1 = result.w1;
                w2 = result.w2;
                currentStep++;
                
                gradientPath.push({ w1, w2 });
                
                updateInfo(w1, w2, currentStep);
                updatePlots(w1, w2);
                
                setTimeout(runStep, 100);
            }
            
            runStep();
        }

        // Step by step mode
        function stepByStep() {
            if (isRunning) return;
            
            currentStep = 0;
            gradientPath = [];
            
            let w1 = parseFloat(document.getElementById('w1-start').value);
            let w2 = parseFloat(document.getElementById('w2-start').value);
            const learningRate = parseFloat(document.getElementById('learning-rate').value);
            
            gradientPath.push({ w1, w2 });
            
            // Clear previous plots
            Plotly.purge('surface-plot');
            Plotly.purge('contour-plot');
            createSurfacePlot();
            createContourPlot();
            
            updateInfo(w1, w2, currentStep);
            updatePlots(w1, w2);
            
            // Enable step button
            const stepButton = document.createElement('button');
            stepButton.className = 'btn-primary';
            stepButton.textContent = 'Next Step';
            stepButton.onclick = function() {
                const result = gradientDescentStep(w1, w2, learningRate);
                w1 = result.w1;
                w2 = result.w2;
                currentStep++;
                
                gradientPath.push({ w1, w2 });
                
                updateInfo(w1, w2, currentStep);
                updatePlots(w1, w2);
            };
            
            // Replace step by step button
            const buttonGroup = document.querySelector('.button-group');
            const oldStepButton = buttonGroup.querySelector('.btn-success');
            buttonGroup.replaceChild(stepButton, oldStepButton);
        }

        // Reset plots
        function resetPlots() {
            isRunning = false;
            currentStep = 0;
            gradientPath = [];
            
            Plotly.purge('surface-plot');
            Plotly.purge('contour-plot');
            createSurfacePlot();
            createContourPlot();
            
            updateInfo(2.0, 1.5, 0);
            
            // Restore step by step button
            const buttonGroup = document.querySelector('.button-group');
            const stepButton = buttonGroup.querySelector('.btn-primary:last-child');
            if (stepButton.textContent === 'Next Step') {
                const newStepButton = document.createElement('button');
                newStepButton.className = 'btn-success';
                newStepButton.textContent = 'Step by Step';
                newStepButton.onclick = stepByStep;
                buttonGroup.replaceChild(newStepButton, stepButton);
            }
        }

        // Initialize plots
        document.addEventListener('DOMContentLoaded', function() {
            createSurfacePlot();
            createContourPlot();
            updateInfo(2.0, 1.5, 0);
        });
    </script>
</body>
</html> 